# TypeScript Environment Configuration Library

A powerful, type-safe environment configuration library for Node.js applications that automatically generates TypeScript types from your environment files.

## Features

- üîí **Type-safe environment variables** with automatic TypeScript type generation
- üéØ **Multiple data types** - STRING, NUMBER, BOOL, ARRAY, OBJ
- üõ°Ô∏è **Runtime validation** with comprehensive error handling
- üìù **Auto-generated documentation** with comments and schemas
- üîç **Duplicate detection** and environment validation
- üöÄ **Easy integration** with existing Node.js projects

## Installation

```bash
npm install your-env-config-package
```

## Quick Start

### 1. Create your environment file

Create a `.env` file with typed environment variables:

```env
# Database Configuration
STRING DATABASE_URL = "postgresql://localhost:5432/mydb"
NUMBER DATABASE_PORT = 5432
BOOL DATABASE_SSL = true

# API Configuration
STRING API_KEY = "your-secret-api-key"
NUMBER MAX_CONNECTIONS = 100
ARRAY ALLOWED_ORIGINS = ["http://localhost:3000", "https://example.com"]
OBJ REDIS_CONFIG = {"host": "localhost", "port": 6379, "retryDelayOnFailover": 100}

# Feature Flags
BOOL ENABLE_LOGGING = true
BOOL DEBUG_MODE = false
```

### 2. Generate TypeScript types

Add a script to your `package.json`:

```json
{
  "scripts": {
    "generate-env-types": "node -e \"require('./dist/index.js').generateTypes('.env', './src/types/env-types.ts')\""
  }
}
```

Run the type generation:

```bash
npm run generate-env-types
```

This generates a `./src/types/env-types.ts` file with:

```typescript
/**
 * Auto-generated TypeScript types for environment variables
 * Generated from: .env
 * Generated at: 2024-01-15T10:30:00.000Z
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Run generateTypes() to regenerate when .env changes
 */

export interface EnvConfig {
  /** Type: STRING */
  DATABASE_URL: string;
  /** Type: NUMBER */
  DATABASE_PORT: number;
  /** Type: BOOL */
  DATABASE_SSL: boolean;
  /** Type: STRING */
  API_KEY: string;
  /** Type: NUMBER */
  MAX_CONNECTIONS: number;
  /** Type: ARRAY */
  ALLOWED_ORIGINS: any[];
  /** Type: OBJ */
  REDIS_CONFIG: Record<string, any>;
  /** Type: BOOL */
  ENABLE_LOGGING: boolean;
  /** Type: BOOL */
  DEBUG_MODE: boolean;
}

export const envSchema = {
  DATABASE_URL: 'STRING',
  DATABASE_PORT: 'NUMBER',
  DATABASE_SSL: 'BOOL',
  API_KEY: 'STRING',
  MAX_CONNECTIONS: 'NUMBER',
  ALLOWED_ORIGINS: 'ARRAY',
  REDIS_CONFIG: 'OBJ',
  ENABLE_LOGGING: 'BOOL',
  DEBUG_MODE: 'BOOL',
} as const;

export type EnvKey = keyof EnvConfig;
export type EnvType = 'STRING' | 'NUMBER' | 'BOOL' | 'ARRAY' | 'OBJ';

// Utility function to get environment variable keys
export const envKeys: EnvKey[] = [
  'DATABASE_URL',
  'DATABASE_PORT',
  'DATABASE_SSL',
  'API_KEY',
  'MAX_CONNECTIONS',
  'ALLOWED_ORIGINS',
  'REDIS_CONFIG',
  'ENABLE_LOGGING',
  'DEBUG_MODE',
];

// Type guard to check if a key exists in the environment config
export function isEnvKey(key: string): key is EnvKey {
  return envKeys.includes(key as EnvKey);
}
```

### 3. Use in your application

```typescript
import { config, validateEnv } from 'your-env-config-package';
import { EnvConfig, envSchema } from './types/env-types';

// Load and parse environment variables
const { parsedEnv } = config<EnvConfig>({
  path: '.env',
  strict: true,
});

// Validate against schema
if (validateEnv(parsedEnv, envSchema)) {
  // Now parsedEnv is fully typed as EnvConfig
  console.log(`Database URL: ${parsedEnv.DATABASE_URL}`);
  console.log(`Port: ${parsedEnv.DATABASE_PORT}`);
  console.log(`SSL enabled: ${parsedEnv.DATABASE_SSL}`);
  console.log(`Allowed origins: ${parsedEnv.ALLOWED_ORIGINS.join(', ')}`);
  console.log(`Redis host: ${parsedEnv.REDIS_CONFIG.host}`);
} else {
  console.error('Environment validation failed');
  process.exit(1);
}
```

## API Reference

### `generateTypes(envPath?, outputPath?, options?)`

Generates TypeScript types from an environment file.

**Parameters:**

- `envPath` (string, optional): Path to the .env file. Default: `'.env'`
- `outputPath` (string, optional): Output path for generated types. Default: `'./src/types/env-types.ts'`
- `options` (object, optional):
  - `interfaceName` (string): Name of the generated interface. Default: `'EnvConfig'`
  - `includeComments` (boolean): Include comments in generated file. Default: `true`
  - `exportSchema` (boolean): Export schema constant. Default: `true`

**Example:**

```typescript
import { generateTypes } from 'your-env-config-package';

generateTypes('.env.production', './src/types/prod-env.ts', {
  interfaceName: 'ProductionEnv',
  includeComments: false,
  exportSchema: true,
});
```

### `config<T>(options?)`

Parses environment variables and returns a typed object.

**Parameters:**

- `options` (object, optional):
  - `path` (string): Path to environment file. Default: `'.env'`
  - `encoding` (BufferEncoding): File encoding. Default: `'utf8'`
  - `strict` (boolean): Throw on errors vs warn. Default: `false`

**Returns:** `{ parsedEnv: T }`

### `validateEnv<T>(env, schema)`

Validates environment variables against a schema.

**Parameters:**

- `env` (Record<string, EnvValue>): Environment variables to validate
- `schema` (Record<string, EnvType>): Schema to validate against

**Returns:** `boolean` - Type guard that narrows `env` to type `T`

### `createTypedConfig<T>()`

Creates a typed config function for a specific interface.

**Example:**

```typescript
import { createTypedConfig } from 'your-env-config-package';
import { EnvConfig } from './types/env-types';

const getConfig = createTypedConfig<EnvConfig>();
const { parsedEnv } = getConfig({ strict: true });
```

## Supported Types

| Type     | TypeScript Type       | Example Value             |
| -------- | --------------------- | ------------------------- |
| `STRING` | `string`              | `"hello world"`           |
| `NUMBER` | `number`              | `42`, `3.14`              |
| `BOOL`   | `boolean`             | `true`, `false`           |
| `ARRAY`  | `any[]`               | `[1, 2, 3]`, `["a", "b"]` |
| `OBJ`    | `Record<string, any>` | `{"key": "value"}`        |

## Environment File Format

```env
# Comments are supported
TYPE VARIABLE_NAME = value

# Examples:
STRING API_URL = "https://api.example.com"
NUMBER PORT = 3000
BOOL DEBUG = true
ARRAY HOSTS = ["localhost", "example.com"]
OBJ CONFIG = {"timeout": 5000, "retries": 3}
```

**Rules:**

- Variable names must match pattern: `^[a-zA-Z_][a-zA-Z0-9_]*$`
- Strings can be quoted or unquoted
- Arrays and objects must be valid JSON
- Boolean values must be `true` or `false` (case-insensitive)
- Comments start with `#`
- Empty lines are ignored

## Error Handling

The library provides comprehensive error handling:

```typescript
try {
  const { parsedEnv } = config<EnvConfig>({ strict: true });
} catch (error) {
  if (error.message.includes('Environment file not found')) {
    console.error('Please create a .env file');
  } else if (error.message.includes('Invalid number value')) {
    console.error('Check your numeric values in .env');
  } else {
    console.error('Environment parsing failed:', error.message);
  }
}
```

## Development Workflow

### Recommended package.json scripts:

```json
{
  "scripts": {
    "generate-env-types": "node -e \"require('./dist/index.js').generateTypes()\"",
    "generate-env-types:dev": "node -e \"require('./dist/index.js').generateTypes('.env.development', './src/types/dev-env.ts')\"",
    "generate-env-types:prod": "node -e \"require('./dist/index.js').generateTypes('.env.production', './src/types/prod-env.ts')\"",
    "validate-env": "node -e \"const {config,validateEnv}=require('./dist/index.js');const {envSchema}=require('./src/types/env-types.js');const {parsedEnv}=config();console.log('‚úÖ Environment valid:', validateEnv(parsedEnv,envSchema));\""
  }
}
```

### Git hooks integration:

Add to your `.husky/pre-commit` or similar:

```bash
#!/bin/sh
npm run generate-env-types
git add src/types/env-types.ts
```

## Best Practices

1. **Keep .env files out of version control** (add to `.gitignore`)
2. **Commit generated type files** for team consistency
3. **Use environment-specific files** (`.env.development`, `.env.production`)
4. **Validate environment on application startup**
5. **Use meaningful variable names** and group related variables
6. **Document complex object/array structures** in comments

## Examples

### Advanced Usage

```typescript
import {
  config,
  validateEnv,
  createTypedConfig,
} from 'your-env-config-package';
import { EnvConfig, envSchema } from './types/env-types';

// Create environment-specific configs
const getDevConfig = createTypedConfig<EnvConfig>();
const getProdConfig = createTypedConfig<EnvConfig>();

function loadConfig(): EnvConfig {
  const environment = process.env.NODE_ENV || 'development';
  const envFile = `.env.${environment}`;

  const { parsedEnv } = config<EnvConfig>({
    path: envFile,
    strict: true,
  });

  if (!validateEnv(parsedEnv, envSchema)) {
    throw new Error(`Invalid environment configuration in ${envFile}`);
  }

  return parsedEnv;
}

export const env = loadConfig();
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Ensure all tests pass
5. Submit a pull request

## License

MIT License - see LICENSE file for details.
